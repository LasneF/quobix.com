<!doctype html><html lang=en><head><script type=application/ld+json>{"@context":"https://schema.org","@type":"NewsArticle","headline":"How to create a streaming AsyncAPI microservice using golang.","image":["https:\/\/quobix.com\/images\/hero-images\/asyncapi-streaming.png"],"datePublished":"2021-12-21 13:07:35 -0400 -0400","author":{"@type":"Person","name":"Dave Shanley","url":"https://quobix.com/author"}}</script><meta charset=utf-8><link rel=apple-touch-icon sizes=180x180 href=https://quobix.com//apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=https://quobix.com/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://quobix.com/favicon-16x16.png><meta name=description content="quobix::vaccum, The worlds fastest OpenAPI linter. Get started with streaming APIs and microservices defined via AsyncAPI using golang."><meta charset=utf-8><meta name=keywords content="OpenAPI,swagger,linting,linter,vacuum,dave shanley,shanley,code,golang,java,javascript,typescript,quobix,engineer"><link crossorigin=use-credentials rel=manifest href=https://quobix.com/site.webmanifest><meta name=author content="Dave Shanley"><meta name=viewport content="width=device-width,initial-scale=1"><title>quobix: How to create a streaming AsyncAPI microservice using golang.</title><script>(function(e,t,n,s,o){e[s]=e[s]||[],e[s].push({"gtm.start":(new Date).getTime(),event:"gtm.js"});var a=t.getElementsByTagName(n)[0],i=t.createElement(n),r=s!="dataLayer"?"&l="+s:"";i.async=!0,i.src="https://www.googletagmanager.com/gtm.js?id="+o+r,a.parentNode.insertBefore(i,a)})(window,document,"script","dataLayer","GTM-PC979K2")</script><link rel=preload href=https://quobix.com/assets/bundle.js as=script><script src=https://quobix.com/assets/bundle.js></script><style>:root{--global-font-size:17px;--toc-font-size:0.7rem;--breadcrumb-font-size:0.75rem;--childnav-font-size:0.75rem;--nav-font-size:0.95rem;--toc-font-header-size:0.85rem;--rule-item-header-fontsize:1.2rem;--rule-item-details-fontsize:0.8rem;--rule-format-fontsize:0.8rem;--rule-type-fontsize:0.7rem;--rule-severity-fontsize:0.8rem;--rule-recommended-fontsize:0.7rem;--rule-function-fontsize:0.8rem;--rule-recommended-banner-fontsize:1rem;--rule-panel-label:0.7rem;--rule-id-fontsize:2rem;--global-line-height:1.4em;--global-space:10px;--vacuum-navigation-width-v:199px;--vacuum-navigation-width:200px;--font-stack:Menlo, Monaco, Roboto Mono, Lucida Console, Liberation Mono,
            DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace,
            serif;--mono-font-stack:Menlo, Monaco, Roboto Mono, Lucida Console, Liberation Mono,
            DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace,
            serif;--background-color:#0d1117;--background-color-alpha:rgba(13, 17, 23, 0.80);--rule-item-background:rgba(26, 32, 44, 0.51);--rule-recommended-background:rgb(33, 41, 55);--rule-stats-background:#0a0a0a;--rule-item-border:rgba(35, 43, 58, 0.9);--navigation-hover:#b685ff33;--navigation-child-selected:rgba(182, 133, 255, 0.26);--navigation-child-hover:rgba(179, 131, 250, 0.09);--navigation-child-container:rgba(182, 133, 255, 0.10);--page-width:65em;--font-color:#e8e9ed;--invert-font-color:#222225;--secondary-color:#b685ff;--secondary-color-lowalpha:rgba(182, 133, 255, 0.73);--secondary-color-very-lowalpha:rgba(182, 133, 255, 0.23);--secondary-color-shadow:rgb(59, 41, 87);--secondary-color-shadow-mid:rgb(78, 54, 114);--tertiary-color:#a3abba;--primary-color:rgba(98, 196, 255, 1.0);--primary-color-lowalpha:rgba(98, 196, 255, 0.6);--error-color:#ff3c74;--error-font-color:#ff246b;--error-color-lowalpha:rgba(255, 60, 116, 0.4);--progress-bar-background:#3f3f44;--progress-bar-fill:#62c4ff;--code-bg-color:none;--input-style:solid;--display-h1-decoration:none;--bold-text:#e397fa;--terminal-green:#00FF00FF;--terminal-yellow:#fddb00;--hrcolor:#3d3d3d;--code-border:#525252;--string-literal:#fd66e5}</style><link rel=stylesheet href=https://quobix.com/assets/syntax.css><link rel=stylesheet href=https://quobix.com/assets/app.css><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:title" content="How to create a streaming AsyncAPI microservice using golang."><meta property="og:description" content="Get started with streaming APIs and microservices defined via AsyncAPI using golang."><meta property="og:publish_date" content="2021-12-21 13:07:35 -0400 -0400"><meta property="og:url" content="https://quobix.com/articles/asyncapi-streaming-using-golang/"><meta property="og:site_name" content="quobix"><meta property="og:image" content="https://quobix.com/images/hero-images/asyncapi-streaming.png"><meta property="og:image:width" content="1400"><meta property="og:image:height" content="680"><meta property="og:image:secure_url" content="https://quobix.com/images/hero-images/asyncapi-streaming.png"><meta property="og:image:type" content="image/png"><meta property="og:image:alt" content="AsyncAPI streaming microservices with golang"><meta property="article:author" content="https://quobix.com"><meta property="article:publisher" content="https://quobix.com"><meta property="article:section" content="Software"><meta property="article:published_time" content="2021-12-21 13:07:35 -0400 -0400"><meta property="article:modified_time" content="2021-12-21 13:07:35 -0400 -0400"><meta name=twitter:card content="summary_large_image"><meta name=twitter:site content="@daveshanley"><meta name=twitter:creator content="@daveshanley"><meta name=twitter:label1 content="Written by"><meta name=twitter:data1 content="Dave Shanley"><meta name=twitter:label2 content="Reading time"><meta name=twitter:data2 content="11 minutes"></head><body class=terminal><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PC979K2" height=0 width=0 style=display:none;visibility:hidden></iframe></noscript><div class=quobix-header><section class=terminal-nav id=main-navigation><header class=terminal-logo><div class="logo terminal-prompt"><a href=https://quobix.com/>quobix</a></div></header><nav class=terminal-menu id=header-menu><ul itemscope itemtype=http://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=http://schema.org/ListItem><a href=https://quobix.com/articles/ itemprop=item class=menu-item><span itemprop=name>Articles</span><meta itemprop=position content="1"></a></li><li itemprop=itemListElement itemscope itemtype=http://schema.org/ListItem><a href=https://quobix.com/author/ itemprop=item class=menu-item><span itemprop=name>Author</span><meta itemprop=position content="2"></a></li><li itemprop=itemListElement itemscope itemtype=http://schema.org/ListItem><a href=https://quobix.com/vacuum/ itemprop=item class=menu-item><span itemprop=name>Vacuum</span><meta itemprop=position content="3"></a></li></ul></nav></section><hr id=top-nav-divider></div><div class=container><div class=main-container><main class=content-container><article class=framed-content><h1 class=article-title>How to create a streaming AsyncAPI microservice using golang.</h1><time datetime="2021-12-21 13:07:35 -0400 -0400">December 21, 2021</time><div class=article-strapline><em>Using WebSockets and STOMP, we will create a streaming server and a client defined by an AsyncAPI contract, in ten minutes.</em></div><section class=article-body><figure><img src=https://quobix.com/images/hero-images/asyncapi-streaming.svg alt="AsyncAPI streaming microservices with golang"><figcaption>Building event driven APIs described with AsyncAPI is easy.</figcaption></figure><h2 id=watch-the-video>Watch the video</h2><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/TnxSlopBYgk style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><hr><p>If you want to learn more about AsyncAPI, head over to <a href=https://asyncapi.com>AsyncAPI.com</a> and find out more about the standard and the power it provides us.</p><p>Moving forward, I will <em>assume</em> that you already know what AsyncAPI is and <strong><em>want to use it in your golang applications</em></strong>.</p><div class=terminal-alert>If you want to check out the source of this article <a href=https://github.com/daveshanley/asyncapi-tutorials/tree/main/streaming>it can be found on GitHub</a>.</div><hr><h2 id=1-getting-started>1. Getting started</h2><p>We&rsquo;re going to create a <strong>microservice</strong> that exposes a single <strong>streaming API</strong> via <strong><em>AsyncAPI</em></strong>.</p><p>Our service will broadcast a message containing a random word every second to any subscribers of its channel (one-to-many).</p><div class=terminal-alert>Let&rsquo;s take a look at the <a href="https://studio.asyncapi.com/?load=https://raw.githubusercontent.com/daveshanley/asyncapi-tutorials/main/specs/simple-stream.yaml">AsyncAPI contract for our Random Word Service</a>.</div><figure class=inline-figure><a href=https://quobix.com/articles/asyncapi-streaming-using-golang/asyncapi-studio.png><img src=https://quobix.com/articles/asyncapi-streaming-using-golang/asyncapi-studio.png title="AsyncAPI Studio is a nice tool for [visualizing our contract](https://studio.asyncapi.com/?load=https://raw.githubusercontent.com/daveshanley/asyncapi-tutorials/main/specs/simple-stream.yaml)." alt="Image of AsyncAPI studio with the contract we're using in this tutorial loaded."></a><figcaption>AsyncAPI Studio is a nice tool for <a href="https://studio.asyncapi.com/?load=https://raw.githubusercontent.com/daveshanley/asyncapi-tutorials/main/specs/simple-stream.yaml">visualizing our contract</a>.</figcaption></figure><hr><p><a href=https://github.com/daveshanley/asyncapi-tutorials/blob/main/specs/simple-stream.yaml>View the contract source on GitHub</a></p><p>The service offers a <strong><em>single subscription channel</em></strong> only, defined as <strong>topic/random-word</strong>.</p><p>Every second, the service broadcasts a random word to all subscribers of that channel.</p><p>Let&rsquo;s look a the definition of the &lsquo;<strong>RandomWord</strong>&rsquo; message broadcast.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=w>  </span><span class=nt>messages</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>RandomWord</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>description</span><span class=p>:</span><span class=w> </span><span class=p>|</span><span class=sd>
</span></span></span><span class=line><span class=cl><span class=sd>        </span><span class=w>        </span><span class=l>A random word for you to enjoy. There is no way to know which word it will be.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>payload</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>allOf</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span>- <span class=nt>$ref</span><span class=p>:</span><span class=w> </span><span class=s1>&#39;#/components/schemas/TransportResponse&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span>- <span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>object</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>properties</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>payload</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>type</span><span class=p>:</span><span class=w> </span><span class=l>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>description</span><span class=p>:</span><span class=w> </span><span class=l>A random english word.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nt>examples</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span>- <span class=l>pizza</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span>- <span class=l>motorcycle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span>- <span class=l>guitars</span></span></span></code></pre></div><p>We can see that it&rsquo;s composed of two elements, properties defined by <strong>TransportResponse</strong> and a <strong>payload</strong> property, consisting of a <em>string</em>, which is our random word.</p><div class=terminal-card><header>Introducing Transport and Plank</header><div><p>This tutorial uses <a href=https://github.com/vmware/transport-go/tree/main/plank>Plank</a> to provide all the socket, message broker, boilerplate, and glue code you typically need to implement AsyncAPI services.</p><p><a href=https://github.com/vmware/transport-go/tree/main/plank>Plank</a> is a part of <a href=https://github.com/vmware/transport-go>Transport</a>, which operates as an asynchronous application framework for go.</p><p>Transport will wrap any response emitted by a service with these properties and make the service response available via the &lsquo;<strong>payload</strong>&rsquo; value. The &lsquo;<strong>payload</strong>&rsquo; can be an object, a primitive, or a string.</p></div></div><hr><h2 id=2-creating-our-random-word-service>2. Creating our Random Word Service</h2><p>The output of our Random Word Service will be just a string, so the payload of our API response is that random word that our service emits.</p><p>Let&rsquo;s start by importing Transport into a new project.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>go get github.com/vmware/transport-go</span></span></code></pre></div><p>Next, let&rsquo;s create the directory in which our AsyncAPI enabled services will live.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>mkdir services</span></span></code></pre></div><p>Now we can create our new Random Word Service, create a new file named &lsquo;<a href=https://github.com/daveshanley/asyncapi-tutorials/blob/main/streaming/services/word_service.go>word_service.go</a>&rsquo;</p><p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>services</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;reflect&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/google/uuid&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/robfig/cron/v3&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/vmware/transport-go/model&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/vmware/transport-go/service&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>RandomWordChannel</span> <span class=p>=</span> <span class=s>&#34;random-word&#34;</span> <span class=c1>// matches asyncapi destination channel.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// RandomWordService will broadcast a random word on the &#34;simple-stream&#34; channel, every one second.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>RandomWordService</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>words</span>         <span class=p>[]</span><span class=kt>string</span>                  <span class=c1>// list of random words.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>transportCore</span> <span class=nx>service</span><span class=p>.</span><span class=nx>FabricServiceCore</span> <span class=c1>// reference to transport services we will need later on.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>readyChan</span>     <span class=kd>chan</span> <span class=kt>bool</span>                 <span class=c1>// once we&#39;re ready, let plank know via this channel.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>cronJob</span>       <span class=o>*</span><span class=nx>cron</span><span class=p>.</span><span class=nx>Cron</span>                <span class=c1>// cronjob that runs every 1s.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// NewRandomWordService will return a new instance of RandomWordService
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>NewRandomWordService</span><span class=p>()</span> <span class=o>*</span><span class=nx>RandomWordService</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=nx>RandomWordService</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div>The <code>RandomWordService</code> struct defines a string slice named <code>words</code>, our random word broadcast source. It also defines a pointer to <code>transportCore</code>, which provides access to Transport context and other useful features.</p><p>The service also defines a <code>readyChan</code>, which lets Plank know that the service has loaded up our random words and is ready to go.</p><p>The last property is a pointer to a <a href=https://github.com/robfig/cron/v3>cron job</a> that will allow us to execute something over and over, <strong><em>forever</em></strong>.</p><hr><h2 id=3-generating-random-words>3. Generating random words</h2><p>Before broadcasting random words, we need to add logic that generates a pool of random words from which to pick.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Init will fire when our service is being registered by Plank. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>Init</span><span class=p>(</span><span class=nx>core</span> <span class=nx>service</span><span class=p>.</span><span class=nx>FabricServiceCore</span><span class=p>)</span> <span class=kt>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// capture a reference to transport core services.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nx>transportCore</span> <span class=p>=</span> <span class=nx>core</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// OnServiceReady fires once Plank has all services loaded and ready to run. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>OnServiceReady</span><span class=p>()</span> <span class=kd>chan</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rws</span><span class=p>.</span><span class=nx>readyChan</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// fetch a list of random words (which runs asynchronously), so it immediately returns.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nf>fetchRandomWords</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>rws</span><span class=p>.</span><span class=nx>readyChan</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p><code>Init</code> and <code>OnServiceReady</code> are lifecycle hooks. They fire after Plank loads the service (<code>Init</code>), and Once Plank is ready to run the service (<code>OnServiceReady</code>).</p><p><code>OnServiceReady</code> Returns a <em>boolean</em> chan that Plank will listen for a signal on before completing activation. We capture a pointer to it named <code>readyChan</code></p><hr><h3 id=31--using-another-api-to-generate-a-list-of-random-words>3.1 Using another API to generate a list of random words.</h3><p>We call &lsquo;<strong>fetchRandomWords</strong>&rsquo;, which makes an API call using a built-in REST Service provided by Transport.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// fetchRandomWords will call a public REST endpoint that very kindly returns random words.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>fetchRandomWords</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>restRequest</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>service</span><span class=p>.</span><span class=nx>RestServiceRequest</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Uri</span><span class=p>:</span>          <span class=s>&#34;https://random-word-api.herokuapp.com/word?number=500&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>Method</span><span class=p>:</span>       <span class=s>&#34;GET&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>ResponseType</span><span class=p>:</span> <span class=nx>reflect</span><span class=p>.</span><span class=nf>TypeOf</span><span class=p>(</span><span class=nx>rws</span><span class=p>.</span><span class=nx>words</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Transport provides a REST Service that makes this API call and provides handlers for the result.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nx>transportCore</span><span class=p>.</span><span class=nf>RestServiceRequest</span><span class=p>(</span><span class=nx>restRequest</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=nx>rws</span><span class=p>.</span><span class=nx>handleWordFetchSuccess</span><span class=p>,</span> <span class=c1>// handle a successful API call.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>rws</span><span class=p>.</span><span class=nx>handleWordFetchFailure</span><span class=p>)</span> <span class=c1>// handle a failed API call.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span></span></span></code></pre></div><p>It will call a public API (<a href=https://random-word-api.herokuapp.com>https://random-word-api.herokuapp.com</a>) that will generate random words for us.</p><p>We ask the API for 500 random words via the REST Service and then handle the success or failure of that API call by providing success and failure functions as handlers.</p><hr><h3 id=32-handling-a-successful-random-word-api-call>3.2 Handling a successful random word API call</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// handleWordFetchSuccess will parse a successful incoming word response from our source API.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>handleWordFetchSuccess</span><span class=p>(</span><span class=nx>response</span> <span class=o>*</span><span class=nx>model</span><span class=p>.</span><span class=nx>Response</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// set the word list to the response returned by the REST API Call.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nx>words</span> <span class=p>=</span> <span class=nx>response</span><span class=p>.</span><span class=nx>Payload</span><span class=p>.([]</span><span class=kt>string</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// send a signal down our ready channel, so Plank knows to continue.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nx>readyChan</span> <span class=o>&lt;-</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>In our success handler <code>handleWordFetchSuccess</code>, we cast the response of the API call into a &lsquo;<strong>[]string</strong>&rsquo; slice. We send a bool down our <code>readyChan</code> to alert Plank that we&rsquo;re ready to go.</p><h3 id=33-handling-a-failed-random-word-api-call>3.3 Handling a failed random word API call</h3><p>If our failure handler <code>handleWordFetchFailure</code> activates, we make up some random words of our own and proceed anyway. The list isn&rsquo;t very long, but it still fulfills the contract.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// handleWordFetchFailure will parse a failed random word API request.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>handleWordFetchFailure</span><span class=p>(</span><span class=nx>response</span> <span class=o>*</span><span class=nx>model</span><span class=p>.</span><span class=nx>Response</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// now we have no data, so make something up using some hard coded values.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nx>words</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&#34;magnum&#34;</span><span class=p>,</span> <span class=s>&#34;fox&#34;</span><span class=p>,</span> <span class=s>&#34;kitty&#34;</span><span class=p>,</span> <span class=s>&#34;cotton&#34;</span><span class=p>,</span> <span class=s>&#34;ember&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// we have a back up data-set loaded.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nx>readyChan</span> <span class=o>&lt;-</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><h2 id=4-adding-the-cron-job>4. Adding the cron job</h2><p>Next, we add code that sets up a repeating cron job. It will send a broadcast message every second to all channel subscribers containing a random word using a simple function that picks it from our service&rsquo;s list in memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// fireRandomWords will create a cron job that repeats every minute, that sends a message to all subscribers
</span></span></span><span class=line><span class=cl><span class=c1>// every minute. We then capture a pointer to that cronjob on our RandomWordService.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>fireRandomWords</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// function to fire every second.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>fireMessage</span> <span class=p>=</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>id</span> <span class=o>:=</span> <span class=nx>uuid</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// send a message containing a random word.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>rws</span><span class=p>.</span><span class=nx>transportCore</span><span class=p>.</span><span class=nf>SendResponse</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>model</span><span class=p>.</span><span class=nx>Request</span><span class=p>{</span><span class=nx>Id</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>id</span><span class=p>},</span> <span class=nx>rws</span><span class=p>.</span><span class=nf>getRandomWord</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>rws</span><span class=p>.</span><span class=nx>cronJob</span> <span class=p>=</span> <span class=nx>cron</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>rws</span><span class=p>.</span><span class=nx>cronJob</span><span class=p>.</span><span class=nf>AddFunc</span><span class=p>(</span><span class=s>&#34;@every 1s&#34;</span><span class=p>,</span> <span class=nx>fireMessage</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>rws</span><span class=p>.</span><span class=nx>cronJob</span><span class=p>.</span><span class=nf>Start</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// getRandomWord will return a random word from our in memory list.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>getRandomWord</span><span class=p>()</span> <span class=kt>string</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>rws</span><span class=p>.</span><span class=nx>words</span><span class=p>[</span><span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>rws</span><span class=p>.</span><span class=nx>words</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)]</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>We need to update both our REST Service API <code>handleWordFetchSuccess</code> and <code>handleWordFetchFailure</code> handlers to call this new method.</p><p>It will ensure the service broadcasts an actual list of random words regardless of success or failure to obtain that data.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>handleWordFetchFailure</span><span class=p>(</span><span class=nx>response</span> <span class=o>*</span><span class=nx>model</span><span class=p>.</span><span class=nx>Response</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// start random word cron job.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nf>fireRandomWords</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>handleWordFetchSuccess</span><span class=p>(</span><span class=nx>response</span> <span class=o>*</span><span class=nx>model</span><span class=p>.</span><span class=nx>Response</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span> 
</span></span><span class=line><span class=cl>    <span class=c1>// start random word cron job.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>rws</span><span class=p>.</span><span class=nf>fireRandomWords</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><h2 id=5-add-in-remaining-lifecycle-methods>5. Add in remaining lifecycle methods</h2><p>The last step of building our streaming service is to add in a few more Plank lifecycle methods. First, we want to stop our cron job cleanly when we&rsquo;re shutting down Plank, so we use <code>OnServerShutdown</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// OnServerShutdown will stop the cronjob firing cleanly when Plank shuts down.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>OnServerShutdown</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rws</span><span class=p>.</span><span class=nx>cronJob</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>We don&rsquo;t need to implement the second and third methods, as we don&rsquo;t need them for this tutorial. However, we still need to add them to ensure the contract Plank requires is fulfilled.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// GetRESTBridgeConfig is not used by this service.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>GetRESTBridgeConfig</span><span class=p>()</span> <span class=p>[]</span><span class=o>*</span><span class=nx>service</span><span class=p>.</span><span class=nx>RESTBridgeConfig</span> <span class=p>{</span> <span class=k>return</span> <span class=kc>nil</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// HandleServiceRequest is not used by this servuce.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>rws</span> <span class=o>*</span><span class=nx>RandomWordService</span><span class=p>)</span> <span class=nf>HandleServiceRequest</span><span class=p>(</span><span class=nx>r</span> <span class=o>*</span><span class=nx>model</span><span class=p>.</span><span class=nx>Request</span><span class=p>,</span> <span class=nx>c</span> <span class=nx>service</span><span class=p>.</span><span class=nx>FabricServiceCore</span><span class=p>){}</span></span></span></code></pre></div><p>Our streaming service is complete; now it&rsquo;s time to serve it via Plank.</p><hr><h2 id=6-creating-the-server-to-run-the-service>6. Creating the server to run the service</h2><p>Let&rsquo;s create a new directory named &lsquo;<em>server</em>&rsquo; and add &lsquo;<a href=https://github.com/daveshanley/asyncapi-tutorials/blob/main/streaming/server/server.go>server.go</a>&rsquo; to it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>mkdir server</span></span></code></pre></div><p>The &lsquo;<strong>main</strong>&rsquo; function first creates a new instance of Plank that we name &lsquo;<strong>platformServer</strong>&rsquo; using a default configuration.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/daveshanley/asyncapi-tutorials/streaming/services&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/vmware/transport-go/plank/pkg/server&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/vmware/transport-go/plank/utils&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// main will create a new instance of plank using a default configuration.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// create a default server configuration.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>serverConfig</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>server</span><span class=p>.</span><span class=nf>CreateServerConfig</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>utils</span><span class=p>.</span><span class=nx>Log</span><span class=p>.</span><span class=nf>Fatalln</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// create a new platform server from our configuration.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>platformServer</span> <span class=o>:=</span> <span class=nx>server</span><span class=p>.</span><span class=nf>NewPlatformServer</span><span class=p>(</span><span class=nx>serverConfig</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// register our RandomWordService with our platform server.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=nx>err</span> <span class=p>=</span> <span class=nx>platformServer</span><span class=p>.</span><span class=nf>RegisterService</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=nx>services</span><span class=p>.</span><span class=nf>NewRandomWordService</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>            <span class=nx>services</span><span class=p>.</span><span class=nx>RandomWordChannel</span><span class=p>);</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>utils</span><span class=p>.</span><span class=nx>Log</span><span class=p>.</span><span class=nf>Fatalln</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// register a system channel with the platform, so we can catch interrupts and shut down cleanly.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>syschan</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=nx>os</span><span class=p>.</span><span class=nx>Signal</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// start plank and start streaming random words to everyone.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>platformServer</span><span class=p>.</span><span class=nf>StartServer</span><span class=p>(</span><span class=nx>syschan</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><p>Next, we create a new instance of <code>RandomWordService</code> and register with <code>platformServer</code> This will run the <code>Init</code> and <code>OnServiceReady</code> methods mentioned earlier.</p><p>The last step is to capture any operating system interrupt commands (<em>like Ctrl-C</em>) to shut down the platform <strong><em>cleanly</em></strong> and pass them to the <code>platformServer</code> pointer.</p><hr><h2 id=7-boot-the-server>7. Boot the server</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>go run server/server.go</span></span></code></pre></div><figure class=inline-figure><a href=https://quobix.com/articles/asyncapi-streaming-using-golang/plank-running.png><img src=https://quobix.com/articles/asyncapi-streaming-using-golang/plank-running.png title="Random Word Service is up and running" alt="Image of a console window, showing the Plank boot screen with Plank running the new service."></a><figcaption>Random Word Service is up and running</figcaption></figure><p>You should see the Plank boot screen, which tells you that the platform is up and running on <strong><em>localhost</em></strong> on port <strong>30080</strong>. The &lsquo;<strong><em>Fabric endpoint</em></strong>&rsquo; is a WebSocket endpoint that is open and listening for STOMP connections.</p><blockquote><p>How do we <strong><em>consume</em></strong> it however?</p></blockquote><hr><h2 id=8-create-a-client-to-connect-and-listen-to-the-word-stream>8. Create a client to connect and listen to the word stream</h2><p>Let&rsquo;s write a client to connect to our new local broker, subscribe to our new service broadcasting on &lsquo;<strong>/topic/random-word</strong>&rsquo;, listen for <strong><em>ten</em></strong> random words and then disconnect.</p><p>Let&rsquo;s create a new file called &lsquo;<a href=https://github.com/daveshanley/asyncapi-tutorials/blob/main/streaming/client.go>client.go</a>&rsquo;</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;encoding/json&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/vmware/transport-go/bridge&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/vmware/transport-go/bus&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/vmware/transport-go/model&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;github.com/vmware/transport-go/plank/utils&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// create a message broker connector config and connect to
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// localhost over WebSocket on port 30080.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>config</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>bridge</span><span class=p>.</span><span class=nx>BrokerConnectorConfig</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>Username</span><span class=p>:</span>   <span class=s>&#34;guest&#34;</span><span class=p>,</span>            <span class=c1>// not required for demo, but our API requires it.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>Password</span><span class=p>:</span>   <span class=s>&#34;guest&#34;</span><span class=p>,</span>            <span class=c1>// ^^ same.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>ServerAddr</span><span class=p>:</span> <span class=s>&#34;localhost:30080&#34;</span><span class=p>,</span>  <span class=c1>// our local plank instance, running RandomWordService
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>UseWS</span><span class=p>:</span>      <span class=kc>true</span><span class=p>,</span>               <span class=c1>// connect over websockets
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>WebSocketConfig</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>bridge</span><span class=p>.</span><span class=nx>WebSocketConfig</span><span class=p>{</span>   <span class=c1>// configure websocket
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>WSPath</span><span class=p>:</span> <span class=s>&#34;/ws&#34;</span><span class=p>,</span>                          <span class=c1>// websocket endpoint
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>UseTLS</span><span class=p>:</span> <span class=kc>false</span><span class=p>,</span>                          <span class=c1>// this isn&#39;t required locally
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}}</span></span></span></code></pre></div><p class=codesplit>First, we create a new message broker configuration that defines &lsquo;<strong>localhost:30080</strong>&rsquo; as our server address and that we want to use WebSockets. We set the WebSocket path to &lsquo;<strong>/ws</strong>&rsquo;, which is the default for Plank.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// get a pointer to transport
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>b</span> <span class=o>:=</span> <span class=nx>bus</span><span class=p>.</span><span class=nf>GetBus</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// get a pointer to transport&#39;s channel manager
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>cm</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>GetChannelManager</span><span class=p>()</span>   
</span></span></code></pre></div><p class=codesplit>Next, we grab a couple of pointers to the event bus and bus channel manager provided by Transport.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// connect to localhost:30080
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>c</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>ConnectBroker</span><span class=p>(</span><span class=nx>config</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>utils</span><span class=p>.</span><span class=nx>Log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;unable to connect to %s, error: %v&#34;</span><span class=p>,</span> <span class=nx>config</span><span class=p>.</span><span class=nx>ServerAddr</span><span class=p>,</span> <span class=nx>err</span><span class=p>.</span><span class=nf>Error</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>  
</span></span></code></pre></div><p class=codesplit>Once we have those pointers, we can connect to our Plank server running locally on port <strong>30080</strong>. Now, let&rsquo;s create a channel on our application event bus called &lsquo;<strong>my-local-word-stream</strong>,&rsquo; and then we create a stream handler that captures all messages on that channel.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// create a local channel on the bus that we want to listen to in our application.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>myLocalChan</span> <span class=o>:=</span> <span class=s>&#34;my-local-word-stream&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>cm</span><span class=p>.</span><span class=nf>CreateChannel</span><span class=p>(</span><span class=nx>myLocalChan</span><span class=p>)</span></span></span></code></pre></div><p class=codesplit>Next, we map our application channel &lsquo;<strong>my-local-word-stream</strong>&rsquo; to the AsyncAPI channel defined by our service &lsquo;<strong>/topic/random-word</strong>&rsquo;.</p><div class="terminal-alert terminal-alert-primary">Transport defines &lsquo;<strong><em>Galactic Channels</em></strong>&rsquo; as event bus channels mapped to an AsyncAPI channel or Message Broker destination.</div><p class=codesplit>We can listen to a channel on our event bus by using the <code>ListenStream</code> method. It will return a stream handler that we will define as <code>handler</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// listen to stream of messages coming in on channel, a handler is returned
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// that allows you to add in lambdas that handle your success messages, and your errors.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>handler</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>b</span><span class=p>.</span><span class=nf>ListenStream</span><span class=p>(</span><span class=nx>myLocalChan</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// mark our local &#39;my-local-word-stream&#39; myLocalChan as &#39;galactic&#39; and map it to our connection and
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// the /topic/random-word service
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>err</span> <span class=p>=</span> <span class=nx>cm</span><span class=p>.</span><span class=nf>MarkChannelAsGalactic</span><span class=p>(</span><span class=nx>myLocalChan</span><span class=p>,</span> <span class=s>&#34;/topic/random-word&#34;</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>utils</span><span class=p>.</span><span class=nx>Log</span><span class=p>.</span><span class=nf>Fatalf</span><span class=p>(</span><span class=s>&#34;unable to map local channel to broker destination: %e&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span></span></span></code></pre></div><p class=codesplit>Our <code>handler</code> will allow us to register functions that capture all messages and errors. We don&rsquo;t want to stream forever, so let&rsquo;s put a ceiling of ten on our stream by using a <code>WaitGroup</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// create a wait group that will wait 10 times before completing.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>var</span> <span class=nx>wg</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>WaitGroup</span>
</span></span><span class=line><span class=cl>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span></span></span></code></pre></div><p><p class=codesplit>Now we have our stream handler and our wait group defined, we can define functions that handle incoming messages and errors.</p><p class=codesplit>If you recall the <a href="https://studio.asyncapi.com/?load=https://raw.githubusercontent.com/daveshanley/asyncapi-tutorials/main/specs/simple-stream.yaml">AsyncAPI contract</a>, All responses that use Plank over AsyncAPI are an object that Transport provides containing a <code>Payload</code> property.</p></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// start and keep listening
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>handler</span><span class=p>.</span><span class=nf>Handle</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=kd>func</span><span class=p>(</span><span class=nx>msg</span> <span class=o>*</span><span class=nx>model</span><span class=p>.</span><span class=nx>Message</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kd>var</span> <span class=nx>randomWord</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>            <span class=nx>msg</span><span class=p>.</span><span class=nf>CastPayloadToType</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>randomWord</span><span class=p>)</span></span></span></code></pre></div><p class=codesplit>We will log it out to the console (because it&rsquo;s just a string) and then mark our wait group as done, incrementing its internal counter.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>            <span class=c1>// log it out.
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nx>utils</span><span class=p>.</span><span class=nx>Log</span><span class=p>.</span><span class=nf>Infof</span><span class=p>(</span><span class=s>&#34;Random word: %s&#34;</span><span class=p>,</span> <span class=nx>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=nx>wg</span><span class=p>.</span><span class=nf>Done</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>        <span class=kd>func</span><span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>utils</span><span class=p>.</span><span class=nx>Log</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;error received on channel: %e&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// wait for 10 ticks of the stream, then we&#39;re done.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>wg</span><span class=p>.</span><span class=nf>Wait</span><span class=p>()</span></span></span></code></pre></div><p class=codesplit>After ten messages from our stream, the <code>WaitGroup</code> will complete. We can clean things up by closing our stream handler and marking our application bus channel as local. Our client will unsubscribe automatically from &lsquo;<strong>/topic/random-word</strong>&rsquo; on our broker.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// close our handler, we&#39;re done.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>handler</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// mark channel as local (unsubscribe from /topic/random-word)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>cm</span><span class=p>.</span><span class=nf>MarkChannelAsLocal</span><span class=p>(</span><span class=nx>myLocalChan</span><span class=p>)</span></span></span></code></pre></div><p class=codesplit>Disconnecting is the last step.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>    <span class=c1>// disconnect from our broker.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>c</span><span class=p>.</span><span class=nf>Disconnect</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div><hr><h2 id=9-run-the-client>9. Run the client</h2><h1 id=hahahugoshortcode-s43-hbhb><div class=highlight><pre tabindex=0 class=chroma><code class=language-zsh data-lang=zsh><span class=line><span class=cl>go run client.go</span></span></code></pre></div></h1><p>You should see Ten random words print out to the console after ten seconds.</p><figure class=inline-figure><a href=https://quobix.com/articles/asyncapi-streaming-using-golang/client-output.png><img src=https://quobix.com/articles/asyncapi-streaming-using-golang/client-output.png title="Ten random words arriving as a stream that ticks every second." alt="Image of a console window, showing the the log output of ten random words."></a><figcaption>Ten random words arriving as a stream that ticks every second.</figcaption></figure><p>And we&rsquo;re done!</p><hr><p>All the code from this tutorial <a href=https://github.com/daveshanley/asyncapi-tutorials/tree/main/streaming>can be found on GitHub</a></p><ul><li><a href=https://github.com/daveshanley/asyncapi-tutorials/blob/main/specs/simple-stream.yaml>Streaming AsyncAPI Specification</a></li><li><a href=https://github.com/daveshanley/asyncapi-tutorials/blob/main/streaming/client.go>client.go</a></li><li><a href=https://github.com/daveshanley/asyncapi-tutorials/blob/main/streaming/server/server.go>server.go</a></li><li><a href=https://github.com/daveshanley/asyncapi-tutorials/blob/main/streaming/services/word_service.go>word_service.go</a></li></ul><p>Head over to <a href=https://transport-bus.io>transport-bus.io</a> if you would like to learn more about Transport as a tool for building full stack asynchronous applications.</p></section><hr><nav class=go-back-parent-link><a href=https://quobix.com/articles/>&lt; Back to Articles</a></nav></article></main></div><footer class=footer><a href=https://quobix.com/author>Dave Shanley</a> 2007-2022
<span class=generated-timestamp>[generated 29/06/22 11:33 UTC]</span></footer></div></body></html>